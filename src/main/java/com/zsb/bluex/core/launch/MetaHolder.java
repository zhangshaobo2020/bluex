package com.zsb.bluex.core.launch;

import com.zsb.bluex.core.anno.BluexClass;
import com.zsb.bluex.core.anno.BluexEnum;
import com.zsb.bluex.core.anno.BluexFunctionLib;
import com.zsb.bluex.core.def.ControlDef;
import com.zsb.bluex.core.def.FunctionDef;
import com.zsb.bluex.core.def.TypeDef;
import com.zsb.bluex.core.resolver.ControlResolver;
import com.zsb.bluex.core.resolver.DelegateResolver;
import com.zsb.bluex.core.resolver.FunctionResolver;
import com.zsb.bluex.core.resolver.TypeResolver;
import com.zsb.bluex.core.utils.MybatisPlusUtils;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;
import org.springframework.core.type.filter.AnnotationTypeFilter;
import org.springframework.stereotype.Component;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

@Slf4j
@Component
public class MetaHolder {

    @Data
    @AllArgsConstructor
    public static class MetaInfo implements Serializable {
        private Map<String, TypeDef> primitiveDef;
        private Map<String, TypeDef> classDef;
        private Map<String, TypeDef> enumDef;
        private Map<String, ControlDef> controlDef;
        private Map<String, ControlDef> delegateDef;
        private Map<String, FunctionDef> functionDef;
        private Map<String, FunctionDef> generatedDef;
        private Map<String, TypeDef> entityDef;
    }

    /**
     * 基本类型
     */
    public static final Map<String, TypeDef> PRIMITIVE_DEFINITION = new LinkedHashMap<>();
    /**
     * 用户自定义类
     */
    public static final Map<String, TypeDef> CLASS_DEFINITION = new LinkedHashMap<>();
    /**
     * 用户自定义枚举
     */
    public static final Map<String, TypeDef> ENUM_DEFINITION = new LinkedHashMap<>();
    /**
     * 流程控制节点
     */
    public static final Map<String, ControlDef> CONTROL_DEFINITION = new LinkedHashMap<>();
    /**
     * 事件委托节点
     */
    public static final Map<String, ControlDef> DELEGATE_DEFINITION = new LinkedHashMap<>();
    /**
     * 用户自定义函数
     */
    public static final Map<String, FunctionDef> FUNCTION_DEFINITION = new LinkedHashMap<>();
    /**
     * 自动生成的工具函数
     */
    public static final Map<String, FunctionDef> GENERATED_DEFINITION = new LinkedHashMap<>();
    /**
     * 数据库实体类
     */
    public static final Map<String, TypeDef> ENTITY_DEFINITION = new LinkedHashMap<>();

    public void process_Primitive() {
        TypeResolver.PRIMITIVE_CLASSES.forEach(clazz -> {
            TypeDef def = TypeResolver.resolveType(clazz);
            PRIMITIVE_DEFINITION.put(clazz.getName(), def);
        });
        TypeResolver.PRIMITIVE_CLASSES.forEach(clazz -> {
            // 处理Getter和Setter
            FunctionDef getter = AutoGeneratedClassHelper.getterForPrimitive(clazz);
            GENERATED_DEFINITION.put(getter.getQualifiedName(), getter);
            FunctionDef setter = AutoGeneratedClassHelper.setterForPrimitive(clazz);
            GENERATED_DEFINITION.put(setter.getQualifiedName(), setter);
        });
    }

    public void process_Control() {
        Map<String, ControlDef> map = ControlResolver.processDefaultControl();
        CONTROL_DEFINITION.putAll(map);
    }

    public void process_Delegate() {
        Map<String, ControlDef> map = DelegateResolver.processDefaultDelegate();
        DELEGATE_DEFINITION.putAll(map);
    }

    public void process_Bluex_Enum(List<String> basePackages) throws Exception {
        ClassPathScanningCandidateComponentProvider scanner =
                new ClassPathScanningCandidateComponentProvider(false);

        scanner.addIncludeFilter(new AnnotationTypeFilter(BluexEnum.class));
        for (String basePackage : basePackages) {
            for (BeanDefinition bd : scanner.findCandidateComponents(basePackage)) {
                registerEnum(Class.forName(bd.getBeanClassName()));
            }
        }
    }

    public static void registerEnum(Class<?> clazz) {
        TypeDef def = TypeResolver.resolveType(clazz);
        ENUM_DEFINITION.put(clazz.getName(), def);
        // 如果@BluexEnum标记了autoFunctions自动生成工具函数
        BluexEnum bluexEnum = clazz.getAnnotation(BluexEnum.class);
        if (bluexEnum != null && bluexEnum.autoGenerated()) {
            FunctionDef fromEnum = AutoGeneratedEnumHelper.fromEnum(clazz);
            GENERATED_DEFINITION.put(fromEnum.getQualifiedName(), fromEnum);
            FunctionDef toEnum = AutoGeneratedEnumHelper.toEnum(clazz);
            GENERATED_DEFINITION.put(toEnum.getQualifiedName(), toEnum);
            ControlDef enumSwitch = AutoGeneratedEnumHelper.enumSwitch(clazz);
            CONTROL_DEFINITION.put(enumSwitch.getQualifiedName(), enumSwitch);
        }
    }

    public static void unregisterEnum(Class<?> clazz) {
        TypeDef def = TypeResolver.resolveType(clazz);
        ENUM_DEFINITION.remove(clazz.getName());
        // 如果@BluexEnum标记了autoFunctions自动生成工具函数
        BluexEnum bluexEnum = clazz.getAnnotation(BluexEnum.class);
        if (bluexEnum != null && bluexEnum.autoGenerated()) {
            FunctionDef fromEnum = AutoGeneratedEnumHelper.fromEnum(clazz);
            GENERATED_DEFINITION.remove(fromEnum.getQualifiedName());
            FunctionDef toEnum = AutoGeneratedEnumHelper.toEnum(clazz);
            GENERATED_DEFINITION.remove(toEnum.getQualifiedName());
            ControlDef enumSwitch = AutoGeneratedEnumHelper.enumSwitch(clazz);
            CONTROL_DEFINITION.remove(enumSwitch.getQualifiedName());
        }
    }

    public void process_Bluex_Class(List<String> basePackages) throws Exception {
        ClassPathScanningCandidateComponentProvider scanner =
                new ClassPathScanningCandidateComponentProvider(false);

        scanner.addIncludeFilter(new AnnotationTypeFilter(BluexClass.class));
        for (String basePackage : basePackages) {
            for (BeanDefinition bd : scanner.findCandidateComponents(basePackage)) {
                registerClass(Class.forName(bd.getBeanClassName()));
            }
        }
    }

    public static void registerClass(Class<?> clazz) {
        TypeDef def = TypeResolver.resolveType(clazz);
        CLASS_DEFINITION.put(clazz.getName(), def);
        // 如果@BluexType标记了autoFunctions自动生成工具函数
        BluexClass bluexClass = clazz.getAnnotation(BluexClass.class);
        if (bluexClass != null && bluexClass.autoGenerated()) {
            FunctionDef getter = AutoGeneratedClassHelper.getter(clazz);
            GENERATED_DEFINITION.put(getter.getQualifiedName(), getter);
            FunctionDef setter = AutoGeneratedClassHelper.setter(clazz);
            GENERATED_DEFINITION.put(setter.getQualifiedName(), setter);
            FunctionDef constructor = AutoGeneratedClassHelper.constructor(clazz);
            GENERATED_DEFINITION.put(constructor.getQualifiedName(), constructor);
            // JSON相关
            FunctionDef fromJSON = AutoGeneratedClassHelper.fromJSON(clazz);
            GENERATED_DEFINITION.put(fromJSON.getQualifiedName(), fromJSON);
            FunctionDef toJSON = AutoGeneratedClassHelper.toJSON(clazz);
            GENERATED_DEFINITION.put(toJSON.getQualifiedName(), toJSON);
            // XML相关
            FunctionDef fromXML = AutoGeneratedClassHelper.fromXML(clazz);
            GENERATED_DEFINITION.put(fromXML.getQualifiedName(), fromXML);
            FunctionDef toXML = AutoGeneratedClassHelper.toXML(clazz);
            GENERATED_DEFINITION.put(toXML.getQualifiedName(), toXML);
            // 是否要激活数据库支持(需要继承Model<?>.class)
            if (MybatisPlusUtils.validateMybatisPlusEntity(clazz)) {
                // 加入数据库实体类缓存
                ENTITY_DEFINITION.put(clazz.getName(), def);
                // SelectById函数
                FunctionDef mybatisPlusSelectById = AutoGeneratedClassHelper.mybatisPlusSelectById(clazz);
                GENERATED_DEFINITION.put(mybatisPlusSelectById.getQualifiedName(), mybatisPlusSelectById);
            }
        }
    }

    public static void unregisterClass(Class<?> clazz) {
        TypeDef def = TypeResolver.resolveType(clazz);
        CLASS_DEFINITION.remove(clazz.getName());
        // 如果@BluexType标记了autoFunctions自动生成工具函数
        BluexClass bluexClass = clazz.getAnnotation(BluexClass.class);
        if (bluexClass != null && bluexClass.autoGenerated()) {
            FunctionDef getter = AutoGeneratedClassHelper.getter(clazz);
            GENERATED_DEFINITION.remove(getter.getQualifiedName());
            FunctionDef setter = AutoGeneratedClassHelper.setter(clazz);
            GENERATED_DEFINITION.remove(setter.getQualifiedName());
            FunctionDef constructor = AutoGeneratedClassHelper.constructor(clazz);
            GENERATED_DEFINITION.remove(constructor.getQualifiedName());
            // JSON相关
            FunctionDef fromJSON = AutoGeneratedClassHelper.fromJSON(clazz);
            GENERATED_DEFINITION.remove(fromJSON.getQualifiedName());
            FunctionDef toJSON = AutoGeneratedClassHelper.toJSON(clazz);
            GENERATED_DEFINITION.remove(toJSON.getQualifiedName());
            // XML相关
            FunctionDef fromXML = AutoGeneratedClassHelper.fromXML(clazz);
            GENERATED_DEFINITION.remove(fromXML.getQualifiedName());
            FunctionDef toXML = AutoGeneratedClassHelper.toXML(clazz);
            GENERATED_DEFINITION.remove(toXML.getQualifiedName());
            // 是否要激活数据库支持(需要继承Model<?>.class)
            if (MybatisPlusUtils.validateMybatisPlusEntity(clazz)) {
                // 加入数据库实体类缓存
                ENTITY_DEFINITION.remove(clazz.getName());
                // SelectById函数
                FunctionDef mybatisPlusSelectById = AutoGeneratedClassHelper.mybatisPlusSelectById(clazz);
                GENERATED_DEFINITION.remove(mybatisPlusSelectById.getQualifiedName());
            }
        }
    }

    public void process_Bluex_Function(List<String> basePackages) throws Exception {
        ClassPathScanningCandidateComponentProvider scanner =
                new ClassPathScanningCandidateComponentProvider(false);

        scanner.addIncludeFilter(new AnnotationTypeFilter(BluexFunctionLib.class));

        List<FunctionDef> definitionList = new ArrayList<>();
        for (String basePackage : basePackages) {
            for (BeanDefinition bd : scanner.findCandidateComponents(basePackage)) {
                Class<?> clazz = Class.forName(bd.getBeanClassName());
                definitionList.addAll(FunctionResolver.resolveFromClass(clazz));
            }
        }
        definitionList.forEach(definition -> {
            // PUT之前校验是否有同名函数
            if (FUNCTION_DEFINITION.containsKey(definition.getQualifiedName())) {
                throw new IllegalArgumentException("检测到同名函数:" + definition.getQualifiedName());
            }
            FUNCTION_DEFINITION.put(definition.getQualifiedName(), definition);
        });
    }
}
