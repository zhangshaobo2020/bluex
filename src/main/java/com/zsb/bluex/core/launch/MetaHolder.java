package com.zsb.bluex.core.launch;

import com.zsb.bluex.core.anno.BluexClass;
import com.zsb.bluex.core.anno.BluexEnum;
import com.zsb.bluex.core.anno.BluexFunctionLib;
import com.zsb.bluex.core.def.ControlDef;
import com.zsb.bluex.core.def.FunctionDef;
import com.zsb.bluex.core.def.TypeDef;
import com.zsb.bluex.core.resolver.ControlResolver;
import com.zsb.bluex.core.resolver.DelegateResolver;
import com.zsb.bluex.core.resolver.FunctionResolver;
import com.zsb.bluex.core.resolver.TypeResolver;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;
import org.springframework.core.type.filter.AnnotationTypeFilter;
import org.springframework.stereotype.Component;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

@Slf4j
@Component
public class MetaHolder {

    @Data
    @AllArgsConstructor
    public static class MetaInfo implements Serializable {
        private Map<String, TypeDef> primitiveDef;
        private Map<String, TypeDef> classDef;
        private Map<String, TypeDef> enumDef;
        private Map<String, ControlDef> controlDef;
        private Map<String, ControlDef> delegateDef;
        private Map<String, FunctionDef> functionDef;
        private Map<String, FunctionDef> generatedDef;
    }

    /**
     * 基本类型
     */
    public static final Map<String, TypeDef> PRIMITIVE_DEFINITION = new LinkedHashMap<>();
    /**
     * 用户自定义类
     */
    public static final Map<String, TypeDef> CLASS_DEFINITION = new LinkedHashMap<>();
    /**
     * 用户自定义枚举
     */
    public static final Map<String, TypeDef> ENUM_DEFINITION = new LinkedHashMap<>();
    /**
     * 流程控制节点
     */
    public static final Map<String, ControlDef> CONTROL_DEFINITION = new LinkedHashMap<>();
    /**
     * 事件委托节点
     */
    public static final Map<String, ControlDef> DELEGATE_DEFINITION = new LinkedHashMap<>();
    /**
     * 用户自定义函数
     */
    public static final Map<String, FunctionDef> FUNCTION_DEFINITION = new LinkedHashMap<>();
    /**
     * 自动生成的工具函数
     */
    public static final Map<String, FunctionDef> GENERATED_DEFINITION = new LinkedHashMap<>();

    public void process_Primitive() {
        TypeResolver.PRIMITIVE_CLASSES.forEach(clazz -> {
            TypeDef def = TypeResolver.resolveType(clazz);
            PRIMITIVE_DEFINITION.put(clazz.getName(), def);
        });
    }

    public void process_Control() {
        Map<String, ControlDef> map = ControlResolver.processDefaultControl();
        CONTROL_DEFINITION.putAll(map);
    }

    public void process_Delegate() {
        Map<String, ControlDef> map = DelegateResolver.processDefaultDelegate();
        DELEGATE_DEFINITION.putAll(map);
    }

    public void process_Bluex_Enum(List<String> basePackages) throws Exception {
        ClassPathScanningCandidateComponentProvider scanner =
                new ClassPathScanningCandidateComponentProvider(false);

        scanner.addIncludeFilter(new AnnotationTypeFilter(BluexEnum.class));
        for (String basePackage : basePackages) {
            for (BeanDefinition bd : scanner.findCandidateComponents(basePackage)) {
                Class<?> clazz = Class.forName(bd.getBeanClassName());
                TypeDef def = TypeResolver.resolveType(clazz);
                ENUM_DEFINITION.put(clazz.getName(), def);
                // 如果@BluexEnum标记了autoFunctions自动生成工具函数
                if (clazz.getAnnotation(BluexEnum.class).autoGenerated()) {
                    FunctionDef fromEnum = AutoGeneratedEnumHelper.fromEnum(clazz);
                    GENERATED_DEFINITION.put(fromEnum.getQualifiedName(), fromEnum);
                    FunctionDef toEnum = AutoGeneratedEnumHelper.toEnum(clazz);
                    GENERATED_DEFINITION.put(toEnum.getQualifiedName(), toEnum);
                    ControlDef enumSwitch = AutoGeneratedEnumHelper.enumSwitch(clazz);
                    CONTROL_DEFINITION.put(enumSwitch.getQualifiedName(), enumSwitch);
                }
            }
        }
    }

    public void process_Bluex_Class(List<String> basePackages) throws Exception {
        ClassPathScanningCandidateComponentProvider scanner =
                new ClassPathScanningCandidateComponentProvider(false);

        scanner.addIncludeFilter(new AnnotationTypeFilter(BluexClass.class));
        for (String basePackage : basePackages) {
            for (BeanDefinition bd : scanner.findCandidateComponents(basePackage)) {
                Class<?> clazz = Class.forName(bd.getBeanClassName());
                TypeDef def = TypeResolver.resolveType(clazz);
                CLASS_DEFINITION.put(clazz.getName(), def);
                // 如果@BluexType标记了autoFunctions自动生成工具函数
                if (clazz.getAnnotation(BluexClass.class).autoGenerated()) {
                    FunctionDef getter = AutoGeneratedClassHelper.getter(clazz);
                    GENERATED_DEFINITION.put(getter.getQualifiedName(), getter);
                    FunctionDef setter = AutoGeneratedClassHelper.setter(clazz);
                    GENERATED_DEFINITION.put(setter.getQualifiedName(), setter);
                    FunctionDef constructor = AutoGeneratedClassHelper.constructor(clazz);
                    GENERATED_DEFINITION.put(constructor.getQualifiedName(), constructor);
                    // JSON相关
                    FunctionDef fromJSON = AutoGeneratedClassHelper.fromJSON(clazz);
                    GENERATED_DEFINITION.put(fromJSON.getQualifiedName(), fromJSON);
                    FunctionDef toJSON = AutoGeneratedClassHelper.toJSON(clazz);
                    GENERATED_DEFINITION.put(toJSON.getQualifiedName(), toJSON);
                    // XML相关
                    FunctionDef fromXML = AutoGeneratedClassHelper.fromXML(clazz);
                    GENERATED_DEFINITION.put(fromXML.getQualifiedName(), fromXML);
                    FunctionDef toXML = AutoGeneratedClassHelper.toXML(clazz);
                    GENERATED_DEFINITION.put(toXML.getQualifiedName(), toXML);
                }
            }
        }
    }

    public void process_Bluex_Function(List<String> basePackages) throws Exception {
        ClassPathScanningCandidateComponentProvider scanner =
                new ClassPathScanningCandidateComponentProvider(false);

        scanner.addIncludeFilter(new AnnotationTypeFilter(BluexFunctionLib.class));

        List<FunctionDef> definitionList = new ArrayList<>();
        for (String basePackage : basePackages) {
            for (BeanDefinition bd : scanner.findCandidateComponents(basePackage)) {
                Class<?> clazz = Class.forName(bd.getBeanClassName());
                definitionList.addAll(FunctionResolver.resolveFromClass(clazz));
            }
        }
        definitionList.forEach(definition -> {
            // PUT之前校验是否有同名函数
            if (FUNCTION_DEFINITION.containsKey(definition.getQualifiedName())) {
                throw new IllegalArgumentException("检测到同名函数:" + definition.getQualifiedName());
            }
            FUNCTION_DEFINITION.put(definition.getQualifiedName(), definition);
        });
    }
}
